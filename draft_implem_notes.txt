//https://sourceforge.net/p/saga-gis/code/ci/master/tree/saga-gis/src/tools/shapes/shapes_tools/shapes_buffer.cpp

try:
	polyt= Qgis.WkbType.PolygonGeomettry
Except:
	polyt=QgsWkbTypes.Polygon

def buffer (geometry,distancem,srcCrs,destCrs):
	fwdtrsctx = QgsCoordinateTransform(srcCrs,destCrs )
	revtrsctx = QgsCoordinateTransform(destCrs,srcCrs )
	result=geometry.transform(fwdtrsctx)
	if not(result):
		raise QgsException("Failed to transform")
	buffered=_buffer(geometry.asGeometryCollection(),distancem)
	result= buffered.transform(revtrsctx)
	if not(result):
		raise QgsExcepiton("could not transform back resulting geometry")
	return(buffered)

def _buffer (geometry,distancem):
	if len(geometry>1):
		buffered_coll=[]
		for geom in  geometry:
			buffered=_buffer( geom)
			buffered_coll.append(buffered)
		return(buffered_coll)
	geometry=geometry[0] //QgsGeometry
	if geometry.isMultipart():
		buffered_coll=[]
		for geom in  geometry.parts():
			buffered=_buffer( geom)
			buffered_coll.append(buffered)
		return(buffered_coll)
	previousVertex=None
	previousAz = None
	buffered=list()
	for vertex in geometry.vertices():

		if (previousVertex is None):
			continue
		
		buffered.append(newbuff)
		buffered = union( buffered, newbuff)
		currentAz = az(vertex,previousVertex)
		if previousAzimuth:
			intAngle = currentAz - previousAz
		

		previousAz=360-currentAz
		previousVertex=vertex

	if (geometry.wkbType() == polyt):
		if ( previousVertex != geoemtry.vertexAt(0) )):
			buffered.append(buffLine(previousVertex, geometry.vertexAt(0))
		buffered = unaryUnion(buffered)
		//check outside and inside range? process as line and merge with polygon, if buffer is negative?
		// buffer as line
		if distance < 0.0:
			buffered=geometry.difference(buffered)
		else:
			buffered=unaryUnion([buffered,geometry])
	elif previousVertex is None: // point
		buffered=make_arcs(srcPnt,distance)
		make points at given interval/precision
	else:
		buffered = unaryUnion(buffered)

	//union if dissolve
	if ( dissolve):
		union(buffered)

	return(buffered) //need to reproject

def buff_line(p1,p2,distance,capstyle,flatstart=False,flatend=False):
	az=InverseLine(lat1, lon1, lat2, lon2,caps=512).azi1
	lim=abs(az)+90
	if flatend:
		precision = 180
	startarc= make_arc(p1,distance,lim,lim+180,180 if flatstart else precision)
	endarc= make_arc(p2,distance,lim,lim-180,180 if flatend else precision)
	//join arcs
	return(polygon(startarc+endarc+startarc[0] ))
	

//https://geographiclib.sourceforge.io/Python/doc/code.html#geographiclib.geodesic.Geodesic.Direct
def make_arc(srcPnt,distance,start=0,end=360,precision=1):

	arc=[]
	for az in range(start,end+precision,precision):
		destPnt=geosgraphlib.Direct(srcPnt.lat,srcPnt.long,az,dist)
		arc.append(QgsPoint(destPnt.lat2,destPnt.long2))

	return(arc)